
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js-small-note</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #f8f9fa;
            --text-color: #212529;
        }
        .post-content {
            max-width: 700px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .post-content img {
            max-width: 100%;
            height: auto;
        }
        .post-content code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .post-content pre code {
            display: block;
            padding: 1em;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="post-content">
        <h1 id="javascript-核心知识点小记">JavaScript 核心知识点小记</h1>
<h2 id="闭包">闭包</h2>
<p>如果在函数外访问函数内的局部变量，正常情况下这无法读取，但是可以通过变通的方法。在函数的内部再定义一个函数。</p>
<pre><code class="language-js">function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
</code></pre>
<p>在JavaScript中只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成一个<strong>定义在一个函数内部的函数</strong>。</p>
<p>闭包最大的特点就是：它能够<strong>记住</strong>诞生的环境，比如<code>f2</code>记住了它的诞生环境是<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。</p>
<p>本质上是，<strong>闭包就是将函数内部和函数外部连接起来的一座桥梁。</strong></p>
<p>其最大的两个用处是：一个是可以读取外层函数内部的变量，另一个是这些变量始终都保持在内存中，即闭包可以使得<strong>它诞生的环境一直存在</strong>。</p>
<p>下面的例子中，闭包使得内部变量记住了上一次调用的运行结果</p>
<pre><code class="language-js">function createIncrementor(start) {
  return function () {
    return start++;
  };
}
var inc = createIncrementor(5);
inc() // 5
inc() // 6
inc() // 7
</code></pre>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，<strong>一直存在</strong>。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。</p>
<p>只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始<strong>终保存着当前值</strong>，供闭包读取。</p>
<p>闭包还可以用于封装对象的<strong>私有属性</strong>和<strong>私有方法</strong></p>
<pre><code class="language-js">function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = Person(&#39;张三&#39;);
p1.setAge(25);
p1.getAge() // 25
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>注意，外层函数每次运行，都会生成一个<strong>新的闭包</strong>，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
</blockquote>
<h2 id="object">Object</h2>
<p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。</p>
<p><strong>静态方法</strong>指的是<code>Object</code>对象自身的方法。</p>
<p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名，<strong>只返回可枚举的属性</strong></p>
<p><code>Object.getOwnPropertyNames</code>方法也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名，<strong>还返回不可枚举的属性名。</strong></p>
<pre><code class="language-js">Object.keys([])
// []
Object.getOwnPropertyNames([])
// [&quot;length&quot;]
</code></pre>
<p>其中数组的<code>length</code>属性是不可枚举的</p>
<p>可以利用这两个方法做一个计算对象属性个数的方法：</p>
<pre><code class="language-js">var obj = {
  p1: 123,
  p2: 456
};

Object.keys(obj).length // 2
Object.getOwnPropertyNames(obj).length // 2
</code></pre>
<hr>
<p><code>Object.prototype.valueOf()</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>
<p><code>Object.prototype.hasOwnProperty()</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象<strong>自身</strong>是否具有该属性，不包括继承的</p>
<p><strong>属性描述对象</strong>用于描述对象的属性，控制它的行为，比如该属性是否可写，可遍历等</p>
<p>每个属性都有自己对应的属性描述对象，保存该属性的一些<strong>元信息</strong>。</p>
<pre><code class="language-js">{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
</code></pre>
<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>
<p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p>
<p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>
<p><code>configurable</code>是一个布尔值，表示属性的可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>
<p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>
<p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。</p>
<p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。<strong>同样只能只能用于对象自身的属性，不能用于继承的属性。</strong>比如<code>toString</code></p>
<p><strong>enumerable: false</strong>可以控制<code>Object.keys</code>的行为，只返回可遍历的属性，<code>Object.getOwnPropertyNames</code>则不行</p>
<p><code>Object.defineProperty()</code>方法允许通过属性描述对象，<strong>定义</strong>或<strong>修改</strong>一个属性，然后返回修改后的对象，它的用法如下。</p>
<pre><code class="language-js">Object.defineProperty(object, propertyName, attributesObject)
</code></pre>
<ul>
<li>object：属性所在的对象</li>
<li>propertyName：字符串，表示属性名</li>
<li>attributesObject：属性描述对象</li>
</ul>
<pre><code class="language-js">obj.p

// 可以写成

var obj = Object.defineProperty({}, &#39;p&#39;, {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});
</code></pre>
<p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法。</p>
<pre><code class="language-js">var obj = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: &#39;abc&#39;, enumerable: true },
  p3: { get: function () { return this.p1 + this.p2 },
    enumerable:true,
    configurable:true
  }
});

obj.p1 // 123
obj.p2 // &quot;abc&quot;
obj.p3 // &quot;123abc&quot;
</code></pre>
<p><code>Object.prototype.propertyIsEnumerable()</code>用来判断某个属性是否可遍历，<strong>对于继承的属性一律返回false</strong></p>
<h3 id="元属性">元属性</h3>
<p><code>value</code>属性是目标属性的值。</p>
<p><code>writable</code>属性是一个布尔值，决定了目标属性的<strong>值（value）</strong>是否可以被改变。</p>
<p><strong>注意：</strong>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么<strong>子对象</strong>将无法自定义这个属性。</p>
<blockquote>
<p>[!tip]</p>
<p>有一个规避方法，就是通<strong>过覆盖属性描述对象</strong>，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>
</blockquote>
<pre><code class="language-js">var proto = Object.defineProperty({}, &#39;foo&#39;, {
  value: &#39;a&#39;,
  writable: false
});

var obj = Object.create(proto);
Object.defineProperty(obj, &#39;foo&#39;, {
  value: &#39;b&#39;
});

obj.foo // &quot;b&quot;
</code></pre>
<p><code>enumerable</code>表示目标属性是否可遍历。</p>
<blockquote>
<p>在早期JavaScript中，<code>for...in</code>循环是基于<code>in</code>运行符的，而<code>in</code>运算符不管某个属性是自身的还是继承的都会返回<code>true</code></p>
<pre><code class="language-js">var obj = {};
&#39;toString&#39; in obj // true
</code></pre>
<p><code>toString</code>不是<code>obj</code>对象自身的属性，但是in返会了true，导致了<code>toString</code>属性也会被for in 循环遍历</p>
<p>再之后，引入了一个 <strong>可遍历性</strong> 这个概念，只有可遍历的属性才能被<code>for in</code> 循环遍历，</p>
<p>并且规定了像<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性。</p>
<p>所以：如果一个属性的<code>enumerable</code>为<code>false</code>，以下操作不会读取到该属性</p>
<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法</li>
</ul>
</blockquote>
<p><code>configurable</code>属性决定了是否可以修改属性描述对象，还决定了目标属性是否可以被删除（delete）</p>
<p>注意，<code>writable</code>属性只有在<code>false</code>改为<code>true</code>时会报错，<code>true</code>改为<code>false</code>是允许的。</p>
<p><code>value</code>属性的情况比较特殊。只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动<code>value</code>。</p>
<h3 id="存取器">存取器</h3>
<pre><code class="language-js">// 写法一
var obj = Object.defineProperty({}, &#39;p&#39;, {
  get: function () {
    return &#39;getter&#39;;
  },
  set: function (value) {
    console.log(&#39;setter: &#39; + value);
  }
});
// 写法二
var obj = {
  get p() {
    return &#39;getter&#39;;
  },
  set p(value) {
    console.log(&#39;setter: &#39; + value);
  }
};
</code></pre>
<p>第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的；</p>
<p>第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，因此属性<code>p</code>是可遍历的。</p>
<p>存取器往往用于，<strong>属性的值依赖对象内部数据</strong>的场合。</p>
<pre><code class="language-js">var obj ={
  $n : 5,
  get next() { return this.$n++ },
  set next(n) {
    if (n &gt;= this.$n) this.$n = n;
    else throw new Error(&#39;新的值必须大于当前值&#39;);
  }
};

obj.next // 5

obj.next = 10;
obj.next // 10

obj.next = 5;
// Uncaught Error: 新的值必须大于当前值
</code></pre>
<h3 id="对象的拷贝">对象的拷贝</h3>
<p>将一个对象的所有属性拷贝到另一个对象</p>
<pre><code class="language-js">var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {
  a: 1
})
// {a: 1}
</code></pre>
<p>上述方法的缺点是遇到<strong>存取器只会拷贝值</strong></p>
<pre><code class="language-js">extend({}, {
  get a() { return 1 }
})
// {a: 1}
</code></pre>
<p>解决办法是通过<code>Object.defineProperty</code>方法来拷贝属性</p>
<pre><code class="language-js">var extend = function (to, from) {
  for (var property in from) {
    if (!from.hasOwnProperty(property)) continue;
    Object.defineProperty(
      to,
      property,
      Object.getOwnPropertyDescriptor(from, property)
    );
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
</code></pre>
<p><code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p>
<h3 id="控制对象状态">控制对象状态</h3>
<p><code>Object.preventExtensions</code>方法可以使得一个对象无法<strong>再添加</strong>新的属性。</p>
<p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。</p>
<p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p>
<blockquote>
<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。<code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值。</p>
</blockquote>
<p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p>
<p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>
<p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p>
<blockquote>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
</blockquote>
<blockquote>
<p>[!tip]</p>
<p>上述方法中，如果操作了被限制的属性，在严格模式下，大部分会报错，否则只是静默失败</p>
</blockquote>
<h3 id="局限性">局限性</h3>
<p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过<strong>改变原型对象</strong>，来为对象增加属性。</p>
<pre><code class="language-js">var obj = new Object();
Object.preventExtensions(obj); // 限制对象

var proto = Object.getPrototypeOf(obj); // 在原型对象操作
proto.t = &#39;hello&#39;;
obj.t // 依然可以读取到
// hello
</code></pre>
<p>解决方案是，把<code>obj</code>的原型也冻结住</p>
<pre><code class="language-js">var obj = new Object();
Object.preventExtensions(obj);

var proto = Object.getPrototypeOf(obj);
Object.preventExtensions(proto);

proto.t = &#39;hello&#39;;
obj.t // undefined
</code></pre>
<p>还有一个局限性是，如果属性值是对象，上述的方法只能冻结属性<strong>指向的对象</strong>，而不能冻结对象的本身的内容。</p>
<pre><code class="language-js">var obj = {
  foo: 1,
  bar: [&#39;a&#39;, &#39;b&#39;]
};
Object.freeze(obj);

obj.bar.push(&#39;c&#39;);
obj.bar // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<p>上述代码中，将<code>obj</code>对象冻结后，<strong>其指向将无法改变，即无法指向其他值</strong>，但是其中的数组是可变的。类似于说，<strong>只能冻结一个对象的顶层属性</strong>，嵌套属性则不行</p>
<h2 id="array">Array</h2>
<p><code>new Array</code>用于生成新的数组，可以传入数字参数，表示生成指定个数成员的数组，每个位置都是空的。</p>
<p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code></p>
<p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身。</p>
<p><code>toString</code>方法返回数组的字符串形式。</p>
<p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<p><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组，对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>。</p>
<blockquote>
<p>[!tip]</p>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）。</p>
</blockquote>
<p><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<blockquote>
<pre><code class="language-js">var list = [1, 2, 3, 4];
var item;

while (item = list.shift()) {
  console.log(item);
}

list // []
</code></pre>
<p>遍历输出并清空一个数组，局限性：数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素</p>
</blockquote>
<p><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组，可以接受多个参数</p>
<p><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>
<pre><code class="language-js">var a = [1, 2, 3, 4];

a.join(&#39; &#39;) // &#39;1 2 3 4&#39;
a.join(&#39; | &#39;) // &quot;1 | 2 | 3 | 4&quot;
a.join() // &quot;1,2,3,4&quot;
</code></pre>
<blockquote>
<p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象。</p>
<pre><code class="language-js">Array.prototype.join.call(&#39;hello&#39;, &#39;-&#39;)
// &quot;h-e-l-l-o&quot;

var obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 };
Array.prototype.join.call(obj, &#39;-&#39;)
// &#39;a-b&#39;
</code></pre>
</blockquote>
<p><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变，其参数可以是数组，数字，字符串....</p>
<blockquote>
<p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</p>
<pre><code>var obj = { a: 1 };
var oldArray = [obj];

var newArray = oldArray.concat();

obj.a = 2;
newArray[0].a // 2
</code></pre>
<p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变。</p>
</blockquote>
<p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p>
<p><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p>
<pre><code class="language-js">arr.slice(start, end);
</code></pre>
<p>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</p>
<p>如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置。</p>
<blockquote>
<p>[!tip]</p>
<p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<pre><code class="language-js">Array.prototype.slice.call({ 0: &#39;a&#39;, 1: &#39;b&#39;, length: 2 })
// [&#39;a&#39;, &#39;b&#39;]

Array.prototype.slice.call(document.querySelectorAll(&quot;div&quot;));
Array.prototype.slice.call(arguments);
</code></pre>
<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组。</p>
</blockquote>
<p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<pre><code class="language-js">arr.splice(start, count, addElement1, addElement2, ...);
</code></pre>
<p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<p>还可以单独插入元素而不删除元素，把<code>splice</code>方法的第二个参数设置为0。如果只提供一个参数，等同于将原数组在指定位置拆分成两个数组</p>
<p><code>sort</code>方法对数组成员进行排序，默认是按照<strong>字典顺序</strong>排序。排序后，原数组将被改变。</p>
<p>如果想让<code>sort</code>方法按照自定义的方式排序，可以传入一个函数作为参数。函数接受两个参数，表示进行比较的两个数组成员，如果函数的返回值大于0，表示第一个成员排在第二个成员后面，其他情况，都是第一个元素排在第二个元素前面。</p>
<blockquote>
<p>[!tip]</p>
<p>注意，自定义的排序函数<strong>应该返回数值</strong>，<strong>而不是布尔值或者其他</strong>，否则不同的浏览器可能有不同的实现，不能保证结果都一致。</p>
</blockquote>
<p><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
<p><code>map()</code>方法接受一个函数作为参数。该函数调用时，<code>map()</code>方法向它（函数）传入三个参数：<strong>当前成员、当前位置和数组本身。</strong></p>
<p><code>map()</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量</p>
<pre><code class="language-js">var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

[1, 2].map(function (e) {
  return this[e];
}, arr)
// [&#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>上述代码中函数内的<code>this</code>指向<code>arr</code>数组。</p>
<blockquote>
<p>[!tip]</p>
<p><code>map()</code>方法的回调函数<strong>不会在空位执行函数</strong>（<code>[&#39;a&#39;,&#39;b&#39;, ,&#39;d&#39;]</code>），但是不会跳过<code>undefined</code>和<code>null</code></p>
</blockquote>
<p><code>forEach()</code>方法与<code>map()</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach()</code>方法<strong>不返回值</strong>，只用来操作数据（比如：为了在屏幕输出内容）。</p>
<p><code>forEach()</code>的用法与<code>map()</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</p>
<p><code>forEach()</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量。</p>
<p>注意，<code>forEach()</code>方法无法中断执行，总是会将所有成员遍历完，<code>forEach()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p>
<p><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p>
<p>它的参数是一个函数，所有数组成员依次执行该函数，<strong>返回结果为</strong><code>true</code><strong>的成员组成一个新数组返回</strong>。该方法不会改变原数组。</p>
<p><code>filter()</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</p>
<p><code>filter()</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<p><code>some</code>方法是只要<strong>一个成员执行函数的返回值是</strong><code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</p>
<p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p>
<p><code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
</code></pre>
<p>上面代码中，<code>reduce()</code>方法用来求出数组所有成员的和。<code>reduce()</code>的参数是一个函数，数组每个成员都会依次执行这个函数。如果数组有 n 个成员，这个参数函数就会执行 n - 1 次。</p>
<ul>
<li>第一次执行：<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。</li>
<li>第二次执行：<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。</li>
<li>第三次执行：<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。</li>
<li>第四次执行：<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</li>
</ul>
<p><code>reduce()</code>方法和<code>reduceRight()</code>方法的第一个参数都是一个函数。该函数接受以下四个参数。</p>
<ol>
<li>累积变量。第一次执行时，默认为数组的第一个成员；以后每次执行时，都是上一轮的返回值。</li>
<li>当前变量。第一次执行时，默认为数组的第二个成员；以后每次执行时，都是下一个成员。</li>
<li>当前位置。一个整数，表示第二个参数（当前变量）的位置，默认为<code>1</code>。</li>
<li>原数组。</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<p>如果要对累积变量<strong>指定初值</strong>，可以把它放在<code>reduce()</code>方法和<code>reduceRight()</code>方法的第二个参数。</p>
<p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置。</p>
<p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
<blockquote>
<p>[!tip]</p>
<p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。</p>
</blockquote>
<h2 id="包装对象">包装对象</h2>
<p>在JavaScript中，原始类型的值：数字，字符串，布尔值，在一定条件下会自动转换为对象，也就是<strong>原始类型的包装对象</strong></p>
<p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把<strong>原始类型的值变成（包装成）对象</strong>。</p>
<pre><code class="language-js">var v1 = new Number(123);
typeof v1 // &quot;object&quot;
v1 === 123 // false
</code></pre>
<p>包装对象的目的是：让整门语言有一个通用的数据模型，<strong>其次是使得原始类型的值也有办法调用自己的方法。</strong></p>
<h3 id="实例方法">实例方法</h3>
<p>三种包装对象各自提供了许多实例方法，其中两种它们共同具有、从<code>Object</code>对象继承的方法：<code>valueOf()</code>和<code>toString()</code>。</p>
<p><code>valueOf()</code>方法返回包装对象实例对应的原始类型的值。</p>
<pre><code class="language-js">new Number(123).valueOf()  // 123
</code></pre>
<p><code>toString()</code>方法返回对应的字符串形式。</p>
<pre><code class="language-js">new Number(123).toString() // &quot;123&quot;
</code></pre>
<h3 id="自动转换">自动转换</h3>
<p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后<strong>立刻销毁实例</strong>。</p>
<pre><code class="language-js">&#39;abc&#39;.length // 3
</code></pre>
<p>上述代码中，<code>abc</code>本身只是一个<strong>普通的字符串</strong>，不是一个对象，所以不能调用<code>length</code>属性</p>
<p>此时，JavaScript 引擎自动将其转为<strong>包装对象</strong>，在这个对象上调用<code>length</code>属性。</p>
<p>调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</p>
<pre><code class="language-js">let str = &#39;abc&#39;;
str.length // 3
</code></pre>
<p>实际上执行的是：</p>
<pre><code class="language-js">let strObj = new String(str)
// String {
//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;
// }
strObj.length // 3
</code></pre>
<p>上面代码中，字符串<code>abc</code>的包装对象提供了多个属性，<code>length</code>只是其中之一。</p>
<p>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</p>
<blockquote>
<p>[!tip]</p>
<p>当调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义</p>
</blockquote>
<h3 id="自定义方法">自定义方法</h3>
<p>除了原生的实例方法，包装对象还可以自定义方法和属性，<strong>供原始类型的值直接调用</strong></p>
<p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍。</p>
<pre><code class="language-js">String.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

&#39;abc&#39;.double()
// abcabc

Number.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

(123).double() // 246
</code></pre>
<p>上面代码在<code>String</code>和<code>Number</code>这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一行的<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点。</p>
<h2 id="boolean-对象">Boolean 对象</h2>
<p><code>Boolean</code>对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</p>
<p>使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值。</p>
<h2 id="number-对象">Number 对象</h2>
<p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p>
<h3 id="静态属性">静态属性</h3>
<blockquote>
<p>[!tip]</p>
<p><strong>静态属性</strong>指的是直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性</p>
</blockquote>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.POSITIVE_INFINITY</code></td>
<td>正的无限，指向<code>Infinity</code></td>
</tr>
<tr>
<td><code>Number.NEGATIVE_INFINITY</code></td>
<td>负的无限，指向<code>-Infinity</code></td>
</tr>
<tr>
<td><code>Number.NaN</code></td>
<td>表示非数值，指向<code>NaN</code></td>
</tr>
<tr>
<td><code>Number.MIN_VALUE</code></td>
<td>表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code></td>
</tr>
<tr>
<td><code>Number.MAX_SAFE_INTEGER</code></td>
<td>表示能够精确表示的最大整数，即<code>9007199254740991</code></td>
</tr>
<tr>
<td><code>Number.MIN_SAFE_INTEGER</code></td>
<td>表示能够精确表示的最小整数，即<code>-9007199254740991</code></td>
</tr>
</tbody></table>
<h3 id="实例方法-1">实例方法</h3>
<h4 id="tostring">toString()</h4>
<p><code>Number.prototype.toString()</code>用来将一个数值转为字符串形式。</p>
<p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</p>
<pre><code class="language-js">(10).toString(2) // &quot;1010&quot;
</code></pre>
<blockquote>
<p>[!tip]</p>
<p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 JavaScript 引擎解释成小数点，从而报错。</p>
<p>当然，只要让JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。</p>
<p>还可以在<code>10</code>后面加两个点，JavaScript 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果。</p>
</blockquote>
<pre><code class="language-js">10..toString(2)
// &quot;1010&quot;

// 其他方法还包括
10 .toString(2) // &quot;1010&quot;
10.0.toString(2) // &quot;1010&quot;
</code></pre>
<p>通过方括号运算符也可以调用<code>toString</code>方法。</p>
<pre><code class="language-js">10[&#39;toString&#39;](2) // &quot;1010&quot;
</code></pre>
<p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法。</p>
<h4 id="tofixed">toFixed()</h4>
<p><code>Number.prototype.toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>
<h4 id="toexponential">toExponential</h4>
<p><code>Number.prototype.toExponential()</code>方法用于将一个数转为科学计数法形式，<code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100</p>
<h4 id="toprecision">toPrecision()</h4>
<p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字，该方法的参数为有效数字的位数，范围是1到100</p>
<h4 id="tolocalestring">toLocaleString</h4>
<p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</p>
<h3 id="自定义方法-1">自定义方法</h3>
<p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承。</p>
<pre><code class="language-js">Number.prototype.add = function (x) {
  return this + x;
};

8[&#39;add&#39;](2) // 10
</code></pre>
<pre><code class="language-js">Number.prototype.iterate = function () {
  var result = [];
  for (var i = 0; i &lt;= this; i++) {
    result.push(i);
  }
  return result;
};

(8).iterate()
// [0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的。</p>
<pre><code class="language-js">var n = 1;
n.x = 1;
n.x // undefined
</code></pre>
<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来。</p>
<h2 id="string-对象">String 对象</h2>
<p><code>String</code>对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</p>
<p>字符串对象是一个类似数组的对象（很像数组，但不是数组）</p>
<pre><code class="language-js">new String(&#39;abc&#39;)
// String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3}

(new String(&#39;abc&#39;))[1] // &quot;b&quot;
</code></pre>
<h3 id="静态方法">静态方法</h3>
<p>...</p>
<h3 id="实例方法-2">实例方法</h3>
<p><code>String.prototype.charAt()</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置</p>
<p><code>String.prototype.concat()</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</p>
<p><code>String.prototype.slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>
<p><code>String.prototype.substring()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p>
<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</p>
<p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。</p>
<p>如果参数是负数，<code>substring</code>方法会自动将负数转为0。</p>
<p><code>String.prototype.indexOf()</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配，该方法还可以接受第二个参数，表示从该位置开始向后匹配。</p>
<p><code>String.prototype.lastIndexOf()</code> 方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配。</p>
<p><code>String.prototype.trim()</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</p>
<p><code>String.prototype.toLowerCase()</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p>
<p><code>String.prototype.match()</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。支持正则表达式作为参数</p>
<p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。</p>
<p><code>String.prototype.search()</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</p>
<p><code>String.prototype.replace()</code> 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</p>
<p><code>String.prototype.split()</code> 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</p>
<pre><code class="language-js">&#39;a|b|c&#39;.split(&#39;|&#39;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<p><code>split</code>方法的第二个参数，决定了返回数组的成员数，支持正则表达式。</p>
<h2 id="math-对象">Math 对象</h2>
<p><code>Math</code>是 JavaScript 的原生对象，提供各种数学功能。<strong>该对象不是构造函数</strong>，不能生成实例，所有的属性和方法都必须在<code>Math</code>对象上调用。</p>
<h3 id="mathabs">Math.abs()</h3>
<p><code>Math.abs</code>方法返回参数值的绝对值。</p>
<h3 id="mathmax">Math.max()</h3>
<p><code>Math.max</code>方法返回参数之中最大的那个值</p>
<h3 id="mathmin">Math.min()</h3>
<p><code>Math.min</code>返回最小的那个值</p>
<h3 id="mathfloor">Math.floor()</h3>
<p><code>Math.floor</code>方法返回<strong>小于或等于</strong>参数值的最大<strong>整数</strong>（地板值）</p>
<pre><code class="language-js">Math.floor(3.2) // 3
Math.floor(-3.2) // -4
</code></pre>
<h3 id="mathceil">Math.ceil()</h3>
<p><code>Math.ceil</code>方法返回大于或等于参数值的最小整数（天花板值）</p>
<pre><code class="language-js">Math.ceil(3.2) // 4
Math.ceil(-3.2) // -3
</code></pre>
<h3 id="mathround">Math.round()</h3>
<p><code>Math.round</code>方法用于四舍五入。</p>
<h3 id="mathrandom">Math.random()</h3>
<p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</p>
<p>任意范围的<strong>随机数</strong>生成函数如下。</p>
<pre><code class="language-js">function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

getRandomArbitrary(1.5, 6.5)
// 2.4942810038223864
</code></pre>
<p>任意范围的<strong>随机整数</strong>生成函数如下。</p>
<pre><code class="language-js">function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

getRandomInt(1, 6) // 5
</code></pre>
<p>返回<strong>随机字符</strong>的例子如下。</p>
<pre><code class="language-js">function random_str(length) {
  var ALPHABET = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;
  ALPHABET += &#39;abcdefghijklmnopqrstuvwxyz&#39;;
  ALPHABET += &#39;0123456789-_&#39;;
  var str = &#39;&#39;;
  for (var i = 0; i &lt; length; ++i) {
    var rand = Math.floor(Math.random() * ALPHABET.length);
    str += ALPHABET.substring(rand, rand + 1);
  }
  return str;
}

random_str(6) // &quot;NdQKOr&quot;
</code></pre>
<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串。</p>
<h2 id="date-对象">Date 对象</h2>
<p>...</p>
<h2 id="regexp-对象">RegExp 对象</h2>
<p>新建正则表达式有两种方法。</p>
<p>一种是使用<strong>字面量</strong>，以斜杠表示开始和结束。</p>
<pre><code class="language-js">var regex = /xyz/;
</code></pre>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<pre><code class="language-js">var regex = new RegExp(&#39;xyz&#39;);
</code></pre>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符</p>
<h3 id="实例方法-3">实例方法</h3>
<h4 id="test">test()</h4>
<p><code>RegExp.prototype.</code> 正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<pre><code class="language-js">/cat/.test(&#39;cats and dogs&#39;) // true
</code></pre>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从<strong>上一次结束</strong>的位置开始向后匹配。</p>
<blockquote>
<p>[!tip]</p>
<p><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</p>
</blockquote>
<pre><code class="language-js">var r = /x/g;
var s = &#39;_x_x&#39;;

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
</code></pre>
<p><code>g</code>修饰符，表示是全局搜索，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<h4 id="exec">exec()</h4>
<p><code>RegExp.prototype.exec()</code>用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
<p>如果正则表达式包含圆括号（即含有“<strong>组匹配</strong>”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。</p>
<p>也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<pre><code class="language-js">var s = &#39;_x_x&#39;;
var r = /_(x)/;

r.exec(s) // [&quot;_x&quot;, &quot;x&quot;]
</code></pre>
<p><code>exec()</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<pre><code class="language-js">var reg = /a/g;
var str = &#39;abc_abc_abc&#39;

while(true) {
  var match = reg.exec(str);
  if (!match) break;
  console.log(&#39;#&#39; + match.index + &#39;:&#39; + match[0]);
}
// #0:a
// #4:a
// #8:a
</code></pre>
<h4 id="match">match()</h4>
<p><code>String.prototype.match()</code>对<strong>字符串</strong>进行正则匹配，返回匹配结果</p>
<pre><code class="language-js">var s = &#39;_x_x&#39;;
var r1 = /x/;
var r2 = /y/;

s.match(r1) // [&quot;x&quot;]
s.match(r2) // null
</code></pre>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，<strong>会一次性返回所有匹配成功的结果。</strong></p>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>
<h4 id="search">search()</h4>
<p><code>String.prototype.search()</code>返回<strong>第一个满足条件</strong>的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>
<pre><code class="language-js">&#39;_x_x&#39;.search(/x/)
// 1
</code></pre>
<h4 id="replace">replace()</h4>
<p><code>String.prototype.replace()</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<pre><code class="language-js">var str = &#39;  #id div.class  &#39;;

str.replace(/^\s+|\s+$/g, &#39;&#39;)
// &quot;#id div.class&quot;
</code></pre>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li>`$``：匹配结果前面的文本。</li>
<li><code>$&#39;</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<pre><code class="language-js">&#39;hello world&#39;.replace(/(\w+)\s(\w+)/, &#39;$2 $1&#39;)
// &quot;world hello&quot;
</code></pre>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<pre><code class="language-js">&#39;3 and 5&#39;.replace(/[0-9]+/g, function (match) {
  return 2 * match;
})
// &quot;6 and 10&quot;

var a = &#39;The quick brown fox jumped over the lazy dog.&#39;;
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.
</code></pre>
<p>函数，可以接受多个参数。</p>
<p>其中，第一个参数是<strong>捕捉到的内容</strong>，第二个参数是捕捉到的<strong>组匹配</strong>（<strong>有多少个组匹配，就有多少个对应的参数</strong>）。</p>
<p>此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的<strong>位置</strong>（比如从第五个位置开始），最后一个参数是<strong>原字符串</strong>。下面是一个网页模板替换的例子。</p>
<h4 id="split">split()</h4>
<p><code>String.prototype.split()</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<pre><code class="language-js">str.split(separator, [limit])
</code></pre>
<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<h2 id="匹配规则">匹配规则</h2>
<h3 id="字面量字符">字面量字符</h3>
<p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。</p>
<pre><code class="language-js">/dog/.test(&#39;old dog&#39;) // true
</code></pre>
<p>如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“<strong>字面量字符</strong>”（literal characters）。</p>
<h3 id="元字符">元字符</h3>
<p>还有一部分字符有特殊含义，不代表字面的意思。它们叫做“<strong>元字符</strong>”（metacharacters），主要有以下几个。</p>
<h4 id="点字符（">点字符（.)</h4>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<pre><code>/c.t/
</code></pre>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<h4 id="位置字符">位置字符</h4>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<pre><code class="language-js">// test必须出现在开始位置
/^test/.test(&#39;test123&#39;) // true

// test必须出现在结束位置
/test$/.test(&#39;new test&#39;) // true

// 从开始位置到结束位置只有test
/^test$/.test(&#39;test&#39;) // true
/^test$/.test(&#39;test test&#39;) // false
</code></pre>
<h4 id="选择符（）">选择符（|）</h4>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<p><strong>选择符会包括它前后的多个字符</strong>，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<pre><code class="language-js">/a( |\t)b/.test(&#39;a\tb&#39;) // true
</code></pre>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<h3 id="转义符">转义符</h3>
<p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<pre><code class="language-js">/1+1/.test(&#39;1+1&#39;)
// false

/1\+1/.test(&#39;1+1&#39;)
// true
</code></pre>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\</code>。</p>
<p>需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<blockquote>
<p>[!tip]</p>
<p><code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
</blockquote>
<h3 id="特殊字符">特殊字符</h3>
<p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h3 id="字符类">字符类</h3>
<p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<pre><code class="language-js">/[abc]/.test(&#39;hello world&#39;) // false
/[abc]/.test(&#39;apple&#39;) // true
</code></pre>
<p><strong>有两个字符在字符类中有特殊含义。</strong></p>
<p><strong>脱字符（^）</strong></p>
<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<pre><code class="language-js">/[^abc]/.test(&#39;bbc news&#39;) // true
/[^abc]/.test(&#39;bbc&#39;) // false
</code></pre>
<p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p>
<blockquote>
<p>[!tip]</p>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
</blockquote>
<p><strong>连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<p><strong>当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义</strong></p>
<blockquote>
<p>[!caution]</p>
<p>不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<pre><code class="language-js">/[A-z]/.test(&#39;\\&#39;) // true
</code></pre>
<p>上面代码中，由于反斜杠（<code>\</code>）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
</blockquote>
<h3 id="预定义模式">预定义模式</h3>
<p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<pre><code class="language-js">// \s 的例子
/\s\w*/.exec(&#39;hello world&#39;) // [&quot; world&quot;]

// \B 的例子
/\Bworld/.test(&#39;hello-world&#39;) // false
/\Bworld/.test(&#39;helloworld&#39;) // true
/\bworld/.test(&#39;hello world&#39;) // true
/\bworld/.test(&#39;hello-world&#39;) // true
/\bworld/.test(&#39;helloworld&#39;) // false

// \B 的例子
/\Bworld/.test(&#39;hello-world&#39;) // false
/\Bworld/.test(&#39;helloworld&#39;) // true
</code></pre>
<p><code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<blockquote>
<p>[!TIP]</p>
<p>通常情况下，正则表达式遇到换行符<code>\n</code>就会停止匹配。</p>
<p>可以使用<code>\s</code>字符类即可匹配包含换行符</p>
</blockquote>
<h3 id="重复类">重复类</h3>
<p>用于描述一个字符出现次数，使用大括号<code>{}</code>表示，<code>{n}</code>表示只能出现<code>n</code>次，<code>{n,}</code>表示最少出现<code>n</code>次，<code>{n,m}</code>表示最少<code>n</code>次，最多<code>m</code>次</p>
<pre><code class="language-js">/lo{2}k/.test(&#39;look&#39;) // true
/lo{2,5}k/.test(&#39;looook&#39;) // true
</code></pre>
<h3 id="量词符">量词符</h3>
<p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</li>
</ul>
<pre><code class="language-js">// t 出现0次或1次
/t?est/.test(&#39;test&#39;) // true
/t?est/.test(&#39;est&#39;) // true

// t 出现1次或多次
/t+est/.test(&#39;test&#39;) // true
/t+est/.test(&#39;ttest&#39;) // true
/t+est/.test(&#39;est&#39;) // false

// t 出现0次或多次
/t*est/.test(&#39;test&#39;) // true
/t*est/.test(&#39;ttest&#39;) // true
/t*est/.test(&#39;tttest&#39;) // true
/t*est/.test(&#39;est&#39;) // true
</code></pre>
<h3 id="贪婪模式">贪婪模式</h3>
<p>刚才讲述的量词符，默认情况下都是最大可能得匹配，即匹配到下一个字符不满足匹配规则为止。这种被称为贪婪模式。</p>
<pre><code class="language-js">let a = &#39;aaa&#39;;
s.match(/a+/) // [&quot;aaa&quot;]
</code></pre>
<p>上面的代码中，模式是<code>a+</code>，表示匹配一个<code>a</code>或者多个<code>a</code>，但是其默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是三个字符<code>a</code>。</p>
<p>量词符默认是<strong>贪婪模式</strong>，当然也可以改成非贪婪模式，即最小可能匹配。<strong>只要一发现匹配，就返回结果</strong>，不要继续往下检查了。</p>
<p><strong>把贪婪模式改为非贪婪模式的方式是在量词符的后面添加一个问号。</strong></p>
<pre><code class="language-js">var s = &#39;aaa&#39;;
s.match(/a+?/) // [&quot;a&quot;]
</code></pre>
<p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<h3 id="修饰符">修饰符</h3>
<p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部，修饰符可以单个使用，也可以多个一起使用。</p>
<pre><code class="language-js">// 单个修饰符
var regex = /test/i;

// 多个修饰符
var regex = /test/ig;
</code></pre>
<h4 id="g-修饰符">g 修饰符</h4>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<h4 id="i-修饰符">i 修饰符</h4>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<h4 id="m-修饰符">m 修饰符</h4>
<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。</p>
<p>默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，<strong>即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）</strong>。</p>
<pre><code class="language-js">/world$/.test(&#39;hello world\n&#39;) // false 不匹配换行符 
/world$/m.test(&#39;hello world\n&#39;) // true
</code></pre>
<pre><code class="language-js">/^b/m.test(&#39;a\nb&#39;) // true
</code></pre>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，<strong>换行符<code>\n</code>也会被认为是一行的开始。</strong></p>
<h3 id="组匹配">组匹配</h3>
<p><strong>概述</strong>：正则表达式的括号表示分<strong>组匹配</strong>，括号中的模式可以用来匹配<strong>分组的内容</strong>。</p>
<pre><code class="language-js">/fred+/.test(&#39;fredd&#39;) // true
/(fred)+/.test(&#39;fredfred&#39;) // true
</code></pre>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示<strong>重复字母</strong><code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code><strong>这个词</strong>。</p>
<pre><code class="language-js">var m = &#39;abcabc&#39;.match(/(.)b(.)/);
m
// [&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;]	第一个代表整个正则的匹配结果，后面是各组匹配的结果
</code></pre>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<blockquote>
<p>[!TIP]</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
</blockquote>
<pre><code class="language-js">var m = &#39;abcabc&#39;.match(/(.)b(.)/g);
m // [&#39;abc&#39;, &#39;abc&#39;]
</code></pre>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<pre><code class="language-js">var str = &#39;abcabc&#39;;
var reg = /(.)b(.)/g;
while (true) {
  var result = reg.exec(str);
  if (!result) break;
  console.log(result);
}
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]
</code></pre>
<p><strong>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容</strong>，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<pre><code class="language-js">/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)
// true
</code></pre>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<pre><code class="language-js">/y(..)(.)\2\1/.test(&#39;yabccab&#39;) // true
</code></pre>
<p><strong>括号还可以嵌套</strong>。</p>
<pre><code class="language-js">/y((..)\2)\1/.test(&#39;yabababab&#39;) // true
</code></pre>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>一个匹配网页标签的例子</p>
<pre><code class="language-js">var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/;

tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1]
// &#39;b&#39;
</code></pre>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<pre><code class="language-js">var html = &#39;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#39;;
var tag = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g;

var match = tag.exec(html);

match[1] // &quot;b&quot;
match[2] // &quot; class=&quot;hello&quot;&quot;
match[3] // &quot;Hello&quot;

match = tag.exec(html);

match[1] // &quot;i&quot;
match[2] // &quot;&quot;
match[3] // &quot;world&quot;
</code></pre>
<p><strong>非捕获组</strong></p>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo){1, 2}/</code>，但是这样会占用一个<strong>组匹配</strong>。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo){1, 2}/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<pre><code class="language-js">var m = &#39;abc&#39;.match(/(?:.)b(.)/);
m // [&quot;abc&quot;, &quot;c&quot;]
</code></pre>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>分解网址的正则表达式。</p>
<pre><code class="language-js">// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec(&#39;http://google.com/&#39;);
// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec(&#39;http://google.com/&#39;);
// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]
</code></pre>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>先行断言</strong></p>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-js">var m = &#39;abc&#39;.match(/b(?=c)/);
m // [&quot;b&quot;]
</code></pre>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<p><strong>先行否定断言</strong></p>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<pre><code class="language-js">/\d+(?!\.)/.exec(&#39;3.14&#39;)
// [&quot;14&quot;]
</code></pre>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<pre><code class="language-js">var m = &#39;abd&#39;.match(/b(?!c)/);
m // [&#39;b&#39;]
</code></pre>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
<h2 id="json-格式">JSON 格式</h2>

    </div>
</body>
</html>